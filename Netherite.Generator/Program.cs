using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Text;
using System.Linq;
using Netherite.Generator.Enums;
using Newtonsoft.Json.Serialization;
using System.Collections.Generic;

namespace Netherite.Generator
{
    class Program
    {
        static void Main(string[] args)
        {
            GenerateItemMaterials();
            GenerateRegistry();
        }

        private static void GenerateBlockMaterials()
        {
            string json = File.ReadAllText("registries.json");
            var obj = JObject.Parse(json);
            var blocks = obj.SelectToken("$['minecraft:block'].entries");
            if (blocks == null)
            {
                throw new NullReferenceException();
            }

            StringBuilder sb = new StringBuilder();
            sb.Append(@"using System;

namespace Netherite.Api
{
    public enum Material
    {");

            foreach (var token in blocks.Children())
            {
                var p = (JProperty)token;
                var name = p.Name;
                var item = JsonConvert.DeserializeObject<ItemJson>(p.Value.ToString());

                var n = name.Split(':', 2)[1];
                var result = "";
                foreach (Match m in new Regex("([a-z]*)").Matches(n))
                {
                    if (m.Value.Length > 0)
                    {
                        result += m.Value[0].ToString().ToUpper();
                        result += m.Value[1..];
                    }
                }

                sb.Append(@$"
        {result}{(token.Next == null ? "" : ",")}");
            }
            sb.Append(@"
    }
}");
            File.WriteAllText("Material.cs", sb.ToString());
        }

        public static DefaultContractResolver ContractResolver { get; } = new DefaultContractResolver
        {
            NamingStrategy = new SnakeCaseNamingStrategy()
        };

        public static JsonSerializerSettings JsonSettings { get; } = new JsonSerializerSettings
        {
            ContractResolver = ContractResolver,
            Converters = new List<JsonConverter>
            {
                new DefaultEnumConverter<CustomDirection>(),
                new DefaultEnumConverter<Axis>(),
                new DefaultEnumConverter<Face>(),
                new DefaultEnumConverter<BlockFace>(),
                new DefaultEnumConverter<EHalf>(),
                new DefaultEnumConverter<Hinge>(),
                new DefaultEnumConverter<Instruments>(),
                new DefaultEnumConverter<Part>(),
                new DefaultEnumConverter<Shape>(),
                new DefaultEnumConverter<CustomDirection>(),
                new DefaultEnumConverter<MinecraftType>(),
                new DefaultEnumConverter<Attachment>()
            }
        };

        private static void GenerateRegistry()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(@"using Netherite.Data.Entities;
using System;
using System.Collections.Generic;
using System.Text;

namespace Netherite.Protocols.v754
{
    // Auto-generated by Netherite
    // Created at " + DateTime.Now.ToString() + @"

    public partial class Registry
    {
        public static readonly Identifier[] Blocks = new Identifier[BlockCount];
        public static readonly MatchTarget[] StateToMatch = new MatchTarget[StateCount];
        public static readonly short[] NumericToBase = new short[BlockCount];

        static Registry()
        {");

            string json = File.ReadAllText("blocks.json");
            var obj = JObject.Parse(json);

            int stateCount = 0;
            int blockCount = 0;

            foreach (var (prop, token) in obj)
            {
                var name = prop.Split(':')[1];
                var states = JsonConvert.DeserializeObject<BlockJson>(token.ToString(), JsonSettings);

                if (!Enum.TryParse(name.Replace("_", ""), true, out Material material))
                {
                    Console.WriteLine($"Didn't find Material {name}, skipping");
                    continue;
                }

                if (states.States.Length <= 0)
                    continue;

                int id = 0;
                foreach (var state in states.States)
                    id = state.Default ? state.Id : states.States.First().Id;

                var baseId = (short)states.States.Min(state => state.Id);
                sb.Append(@$"

            // Material: {material} => Base state ID: {baseId}
            NumericToBase[{(int)material}] = {baseId};

            // Block: {material} => Name: minecraft:{name}
            Blocks[{(int)material}] = new Identifier(""{name}"");");

                foreach (var state in states.States)
                {
                    sb.Append(@$"

            // State ID: {state.Id} => Match(BaseID: {baseId}, Material ID: {(short)material})
            StateToMatch[{state.Id}] = new MatchTarget({baseId}, {(short)material});");

                    stateCount = Math.Max(stateCount, (short)material);
                    blockCount = Math.Max(blockCount, baseId);

                    if (id == state.Id)
                        continue;
                }
            }
            sb.Append(@$"
        }}

        private const int BlockCount = {blockCount+1};
        private const int StateCount = {stateCount+1};
    }}
}}");
            File.WriteAllText("Registry.Generated.cs", sb.ToString());
        }

        private static void GenerateItemMaterials()
        {
            string json = File.ReadAllText("registries.json");
            var obj = JObject.Parse(json);
            var blocks = obj.SelectToken("$['minecraft:item'].entries");
            if (blocks == null)
            {
                throw new NullReferenceException();
            }

            StringBuilder sb = new StringBuilder();
            sb.Append(@"using System;

namespace Netherite.Api
{
    public enum Material
    {");

            foreach (var token in blocks.Children())
            {
                var p = (JProperty)token;
                var name = p.Name;
                var item = JsonConvert.DeserializeObject<ItemJson>(p.Value.ToString());

                var n = name.Split(':', 2)[1];
                var result = "";
                foreach (Match m in new Regex("([a-z0-9]*)").Matches(n))
                {
                    if (m.Value.Length > 0)
                    {
                        result += m.Value[0].ToString().ToUpper();
                        result += m.Value[1..];
                    }
                }

                sb.Append(@$"
        {result}{(token.Next == null ? "" : ",")}");
            }
            sb.Append(@"
    }
}");
            File.WriteAllText("Material.cs", sb.ToString());
        }
    }

    public class DefaultEnumConverter<T> : JsonConverter<T>
    {
        public override T ReadJson(JsonReader reader, Type objectType, T existingValue, bool hasExistingValue, JsonSerializer serializer)
        {
            var val = reader.Value.ToString().Replace("_", "");

            if (Enum.TryParse(typeof(T), val, true, out var result))
                return (T)result;

            throw new InvalidOperationException($"Failed to deserialize: {val}");
        }

        public override void WriteJson(JsonWriter writer, T value, JsonSerializer serializer)
        {
            Regex pattern = new Regex(@"[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+");
            writer.WriteValue(string.Join('_', pattern.Matches(value.ToString())));
        }
    }

    internal class ItemJson
    {
        [JsonProperty("protocol_id")]
        public int ProtocolId { get; set; }
    }

    public class BlockJson
    {
        [JsonProperty("states")]
        public BlockStateJson[] States { get; set; }

        [JsonProperty("properties")]
        public BlockPropertiesExtraJson Properties { get; set; }
    }

    public class BlockStateJson
    {
        [JsonProperty("id")]
        public int Id { get; set; }

        [JsonProperty("default")]
        public bool Default { get; set; }

        [JsonProperty("properties")]
        public BlockPropertiesJson Properties { get; set; }
    }

    public class BlockPropertiesExtraJson
    {
        [JsonProperty("level")]
        public int[] Levels { get; set; }

        [JsonProperty("note")]
        public int[] Notes { get; set; }

        [JsonProperty("age")]
        public int[] Ages { get; set; }

        [JsonProperty("power")]
        public int[] PowerStates { get; set; }

        [JsonProperty("moisture")]
        public int[] MoistureStates { get; set; }

        [JsonProperty("rotation")]
        public int[] RotationStates { get; set; }

        [JsonProperty("layers")]
        public int[] Layers { get; set; }

        [JsonProperty("bites")]
        public int[] BiteStates { get; set; }

        [JsonProperty("delay")]
        public int[] DelayStates { get; set; }

        [JsonProperty("honey_level")]
        public int[] HoneyLevels { get; set; }

        [JsonProperty("axis")]
        public string[] Axis { get; set; }

        [JsonProperty("facing")]
        public string[] Faces { get; set; }

        [JsonProperty("instrument")]
        public string[] Instruments { get; set; }

        [JsonProperty("part")]
        public string[] Parts { get; set; }

        [JsonProperty("shape")]
        public string[] Shapes { get; set; }

        [JsonProperty("half")]
        public string[] HalfStates { get; set; }

        [JsonProperty("type")]
        public string[] Types { get; set; }

        [JsonProperty("hinge")]
        public string[] Hinges { get; set; }

        [JsonProperty("mode")]
        public string[] Mode { get; set; }

        [JsonProperty("attachment")]
        public string[] Attachments { get; set; }
    }

    public class BlockPropertiesJson
    {
        public int Stage { get; set; }
        public int Level { get; set; }
        public int Note { get; set; }
        public int Age { get; set; }
        public int Power { get; set; }
        public int Moisture { get; set; }
        public int Rotation { get; set; }
        public int Layers { get; set; }
        public int Bites { get; set; }
        public int Delay { get; set; }
        public int HoneyLevel { get; set; }
        public int Distance { get; set; }

        public string East { get; set; }
        public string North { get; set; }
        public string South { get; set; }
        public string Up { get; set; }
        public string West { get; set; }
        public string Bottom { get; set; }

        public bool Snowy { get; set; }
        public bool Powered { get; set; }
        public bool Triggered { get; set; }
        public bool Occupied { get; set; }
        public bool Unstable { get; set; }
        public bool Waterlogged { get; set; }
        public bool Lit { get; set; }
        public bool SignalFire { get; set; }
        public bool Hanging { get; set; }
        public bool Opened { get; set; }
        public bool HasRecord { get; set; }
        public bool Locked { get; set; }
        public bool HasBottle0 { get; set; }
        public bool HasBottle1 { get; set; }
        public bool HasBottle2 { get; set; }
        public bool HasBook { get; set; }
        public bool Disarmed { get; set; }
        public bool Attached { get; set; }

        public Axis Axis { get; set; }
        public BlockFace Facing { get; set; }
        public Instruments Instrument { get; set; }
        public Part Part { get; set; }
        public Shape Shape { get; set; }
        public EHalf Half { get; set; }
        public MinecraftType Type { get; set; }
        public Hinge Hinge { get; set; }
        public Face Face { get; set; }
        public Mode Mode { get; set; }
        public Attachment Attachment { get; set; }
    }
}
